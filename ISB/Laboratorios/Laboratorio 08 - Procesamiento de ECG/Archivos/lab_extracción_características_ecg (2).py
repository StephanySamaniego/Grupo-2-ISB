# -*- coding: utf-8 -*-
"""Lab_Extracción_Características_ECG.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BEgQcSLImMIDHlh4_Iv2rx7esg5wKKhm
"""

pip install biosignalnotebooks

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import re
import pywt
from scipy import signal
from scipy.signal import iirnotch, freqz, find_peaks
import biosignalsnotebooks as bsnb

"""## Obtenemos la señal sin filtrar

"""

arrayecg = np.genfromtxt("ecgSignal.txt", delimiter="\t",skip_header = 3, missing_values= 0)

Fs_ecg = 1000
Ts_ecg = 1/Fs_ecg
ecgsignal = arrayecg[:, 5]
ecgsignal = bsnb.raw_to_phy("ECG", "biosignalsplux", ecgsignal, 10, "mV") #Pasamos la señal a mV
time = bsnb.generate_time(ecgsignal, Fs_ecg)
bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Amplitud (mV)")
bokeh_fig.line(time, ecgsignal, legend_label="ECG data")
bokeh_fig.title.text = "Señal ECG Sin Filtrar"
bsnb.show(bokeh_fig)

#Realizamos un analisis frecuencial a la señal rectificada
N = len(ecgsignal)
yf = np.fft.fft(ecgsignal)
xf = np.linspace(0.0, 1.0/(2.0*Ts_ecg), N//2)
bokeh_fig = bsnb.figure(x_axis_label="Frecuencia (Hz)", y_axis_label="Magnitud")
bokeh_fig.line(xf, 2.0/N * np.abs(yf[0:N//2]), legend_label="ECG data Hz")
bokeh_fig.title.text = "Espectro de frecuencias ECG sin filtrar"
bsnb.show(bokeh_fig)

"""## Aplicamos filtros Notch para eliminar 60 y 120 Hz



"""

#Aplicamos un filtro notch digital para eliminar 60 y 120 Hz
# Creamos un filtro notch en 60 Hz
fc = 60.0  # Frecuencia a eliminar
Q = 20.0  # Factor de calidad
w0 = fc/(Fs_ecg / 2)
b, a = iirnotch(w0, Q)
# Aplicamos el filtro creado
ecgsignal_60Hz = lfilter(b, a, ecgsignal)
fc2 = 120 #Segunda frecuencia a eliminar
w0 = fc2/(Fs_ecg / 2)
b, a = iirnotch(w0, Q)
# Aplicamos el filtro creado
ecgsignal__60Hz_120Hz = lfilter(b, a, ecgsignal_60Hz)
ecgsignal_filtrada_parcial = ecgsignal__60Hz_120Hz
#Realizamos un analisis frecuencial
N = len(ecgsignal_filtrada_parcial)
yf = np.fft.fft(ecgsignal_filtrada_parcial)
xf = np.linspace(0.0, 1.0/(2.0*Ts_ecg), N//2)
bokeh_fig = bsnb.figure(x_axis_label="Frecuencia (Hz)", y_axis_label="Magnitud")
bokeh_fig.line(xf, 2.0/N * np.abs(yf[0:N//2]), legend_label="ECG data Hz")
bokeh_fig.title.text = "Espectro de frecuencias ECG filtrada parcialmente (Filtros Notch)"
bsnb.show(bokeh_fig)

#Ploteamos la señal tras filtrarla
bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Amplitud (mV)")
bokeh_fig.line(time, ecgsignal_filtrada_parcial, legend_label="ECG data")
bokeh_fig.title.text = "Señal ECG Filtrada parcialmente(Filtros Notch)"
bsnb.show(bokeh_fig)

"""## Aplicamos filtro Wavelet"""

#Aplicamos filtro wavelet
niveles_ecg = 5
coeficientes_ecg = pywt.wavedec(ecgsignal_filtrada_parcial, 'db9', level=niveles_ecg)

plt.figure(figsize=(10, 10))
plt.subplot(niveles_ecg + 2, 1, 1)
plt.plot(time,ecgsignal_filtrada_parcial)
plt.ylabel('Voltaje (mV)')
plt.xlabel('Tiempo (s)')
plt.title('Señal Original')

for i, detalle in enumerate(coeficientes_ecg[1:]):  # Empezar desde el segundo nivel
    plt.subplot(niveles_ecg + 2, 1, i + 2)
    plt.plot(detalle)
    plt.title(f'Detalle Nivel {i+1}')

plt.subplot(niveles_ecg + 2, 1, niveles_ecg + 2)
plt.plot(coeficientes_ecg[0])
plt.title(f'Aproximación ')
plt.tight_layout()
plt.show()

#Aplicamos el filtro
umbral = 0.022

coeficientes_umbral_ecg = [pywt.threshold(c, umbral, mode='soft') for c in coeficientes_ecg]

senal_filtrada_ecg = pywt.waverec(coeficientes_umbral_ecg, 'db9')

#Ploteamos la señal tras filtrarla
bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Amplitud (mV)")
bokeh_fig.line(time, senal_filtrada_ecg, legend_label="ECG data")
bokeh_fig.title.text = "Señal ECG Filtrada"
bsnb.show(bokeh_fig)

#Realizamos un analisis frecuencial
N = len(senal_filtrada_ecg)
yf = np.fft.fft(senal_filtrada_ecg)
xf = np.linspace(0.0, 1.0/(2.0*Ts_ecg), N//2)
bokeh_fig = bsnb.figure(x_axis_label="Frecuencia (Hz)", y_axis_label="Magnitud")
bokeh_fig.line(xf, 2.0/N * np.abs(yf[0:N//2]), legend_label="ECG data Hz")
bokeh_fig.title.text = "Espectro de frecuencias ECG filtrada"
bsnb.show(bokeh_fig)

"""# Identificando el complejo QRS

## Operador Derivativo
"""

# Filtro derivativo
b = np.array([-1, -2, 0, 2, 1])
b = (1/8)*b
w, h = freqz(b, 1, fs=Fs_ecg)
bokeh_fig = bsnb.figure(x_axis_label="Frecuencia (Hz)", y_axis_label="Magnitud")
bokeh_fig.line(w, 20 * np.log10(abs(h)))
bokeh_fig.title.text = "Filtro derivativo a aplicar"
bsnb.show(bokeh_fig)

#plt.figure(figsize=(10,5))
#plt.plot(w, 20 * np.log10(abs(h)), 'b')
#plt.xlim(0,250)
#plt.ylim(-40,2)
#plt.show()

ecg_signal_derivativo = lfilter(b, 1,senal_filtrada_ecg)
bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Amplitud (mV)")
bokeh_fig.line(time, ecg_signal_derivativo, legend_label="ECG data")
bokeh_fig.title.text = "Señal ECG Filtrada tras operador derivativo"
bsnb.show(bokeh_fig)

"""## Operador Cuadrático"""

# Filtro cuadrado
ecg_signal_sq = np.square(ecg_signal_derivativo)
bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Amplitud")
bokeh_fig.line(time, ecg_signal_sq, legend_label="ECG data")
bokeh_fig.title.text = "Señal ECG Filtrada tras operador derivativo y cuadrático"
bsnb.show(bokeh_fig)

"""## Operador Moving Window Integration"""

# Moving-Window Integration
N = 75
b = np.ones(N-1)
b = (1/N)*b
ecg_signal_mwi = lfilter(b, 1, ecg_signal_sq)
bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Amplitud")
bokeh_fig.line(time, ecg_signal_mwi, legend_label="ECG data")
bokeh_fig.title.text = "Señal ECG Filtrada tras Moving Window Integration"
bsnb.show(bokeh_fig)

"""## Buscamos los picos"""

ecg_signal_mwi_10seg = ecg_signal_mwi[0:10000]
peaks, _ = find_peaks(ecg_signal_mwi_10seg, distance=200)

plt.figure(figsize=(20,5))
plt.plot(ecg_signal_mwi_10seg)
plt.plot(peaks, ecg_signal_mwi_10seg[peaks], "x")
plt.xlabel("Muestras")
plt.ylabel("Amplitud")
plt.show()

"""## Análisis de Threshold  
###Para la identificación del inicio y fin del complejo QRS
"""

f_samples = len(peaks)
th_I1 = np.max(ecg_signal_mwi_10seg[peaks[:f_samples]])*0.25
th_I2 = 0.5*np.mean(ecg_signal_mwi_10seg[peaks[:f_samples]])
print ("El valor del umbral de pico R de entrada es ", th_I1)
print ("El valor del umbral de ruido de entrada es ", th_I2)
plt.figure(figsize=(20,5))
plt.plot(ecg_signal_mwi_10seg)
#plt.xlim(50,1000)
plt.plot(peaks, ecg_signal_mwi_10seg[peaks], "x")
plt.hlines(th_I1, 0, len(ecg_signal_mwi_10seg), colors='green')
plt.hlines(th_I2, 0, len(ecg_signal_mwi_10seg), colors='yellow')
plt.xlabel("Muestras")
plt.ylabel("Amplitud")
plt.show()

end_qrs = ecg_signal_mwi_10seg > th_I1
roll_qrs_r = np.roll(end_qrs, 1)
roll_qrs_l = np.roll(end_qrs, -1)
end_qrs = np.logical_xor(end_qrs ,roll_qrs_r)
end_qrs = np.logical_and(end_qrs ,roll_qrs_l)
plt.figure(figsize=(20,5))
plt.xlim(0,2000)
plt.plot(senal_filtrada_ecg)
plt.plot(end_qrs*np.max(senal_filtrada_ecg))
plt.xlabel("Muestras")
plt.ylabel("Amplitud")
plt.show()

start_qrs = ecg_signal_mwi_10seg < th_I2
roll_qrs_l = np.roll(start_qrs, -1)
roll_qrs_r = np.roll(start_qrs, 1)
start_qrs = np.logical_xor(start_qrs ,roll_qrs_l)
start_qrs = np.logical_and(start_qrs ,roll_qrs_r)
plt.figure(figsize=(20,5))
plt.plot(senal_filtrada_ecg)
plt.xlim(0,2000)
plt.plot(start_qrs*np.max(senal_filtrada_ecg))
plt.xlabel("Muestras")
plt.ylabel("Amplitud")
plt.show()

qrs = np.logical_or(start_qrs, end_qrs)
plt.figure(figsize=(20,5))
plt.xlim(0,2000)
plt.plot(senal_filtrada_ecg)
plt.plot(qrs*np.max(senal_filtrada_ecg))
plt.xlabel("Muestras")
plt.ylabel("Amplitud")
plt.show()

time_10seg = time[0:10000]
qrs = np.logical_or(start_qrs, end_qrs)
plt.figure(figsize=(20,5))
plt.plot(senal_filtrada_ecg)
plt.xlim(0,10000)
plt.plot(qrs*np.max(senal_filtrada_ecg))
plt.title("Señal ECG Filtrada con el complejo QRS Identificado")
plt.xlabel("Muestras")
plt.ylabel("Amplitud")
plt.show()

"""## Extracción BPM y duración R-R
### Para la extracción de algunas características es necesario trabajar con el tacograma de la señal
"""

tachogram_data, tachogram_time = bsnb.tachogram(senal_filtrada_ecg, Fs_ecg, signal=True, out_seconds=True)
bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Cardiac Cycle(s)")
bokeh_fig.line(tachogram_time, tachogram_data)
bokeh_fig.title.text = "Tachogram"
bsnb.show(bokeh_fig)

"""### A veces es necesario eliminar ectopic beats de los tacogramas para que nos den información correcta de la señal que estamos analizando, para ello se realiza lo siguiente:"""

tachogram_data_NN, tachogram_time_NN = bsnb.remove_ectopy(tachogram_data, tachogram_time)
bpm_data = (1 / np.array(tachogram_data_NN)) * 60
bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Cardiac Cycle(s)")
bokeh_fig.line(tachogram_time_NN, tachogram_data_NN)
bokeh_fig.title.text = "Tachogram after ectopic beat removal"
bsnb.show(bokeh_fig)

# Maximum, Minimum and Average RR Interval
max_rr = max(tachogram_data_NN)
min_rr = min(tachogram_data_NN)
avg_rr = np.average(tachogram_data_NN)

# Maximum, Minimum and Average Heart Rate
max_hr = 1 / min_rr # Cycles per second
max_bpm = max_hr * 60 # BPM

min_hr = 1 / max_rr # Cycles per second
min_bpm = min_hr * 60 # BPM

avg_hr = 1 / avg_rr # Cyles per second
avg_bpm = avg_hr * 60 # BPM

# SDNN
sdnn = np.std(tachogram_data_NN)

time_param_dict = {"Maximum RR": max_rr, "Minimum RR": min_rr, "Average RR": avg_rr, "Maximum BPM": max_bpm, "Minimum BPM": min_bpm, "Average BPM": avg_bpm, "SDNN": sdnn}
time_param_dict

"""### Además, la libreria biosignalsnotebooks te permite extraer una lista de características por medio de la función hrv_parameters."""

dictParameters = bsnb.hrv_parameters(senal_filtrada_ecg, Fs_ecg, signal=True)
dictParameters

"""### La librería biosignalsnotebooks también nos permite hacer la identificación de diferentes tipos de picos de manera directa con la función "detect_r_peaks"""

ecg_signal_10seg = senal_filtrada_ecg[0:10000]
detected_peaks = bsnb.detect_r_peaks(ecg_signal_10seg, Fs_ecg, time_units=True, plot_result=True)