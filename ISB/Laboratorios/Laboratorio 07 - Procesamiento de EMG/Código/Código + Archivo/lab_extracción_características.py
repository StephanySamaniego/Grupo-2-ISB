# -*- coding: utf-8 -*-
"""Lab_Extracción_Características.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G6GY8xz3OO-RHDvqWnYJ-qmPX4csFV2T
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import re
import pywt
from scipy import signal
from scipy.signal import firwin, lfilter, iirnotch
import biosignalsnotebooks as bsnb

"""## Obtenemos la señal sin filtrar

"""

arrayemg = np.genfromtxt("EMG_Signal.txt", delimiter="\t",skip_header = 3, missing_values= 0)
#Extraemos la columna de la señal
signalemg = arrayemg[:, 5]
signalemg = bsnb.raw_to_phy("EMG", "biosignalsplux", signalemg, 10, "mV") #Pasamos la señal a mV
Fs_emg = 1000
Ts_emg = 1/Fs_emg
n_emg= len(signalemg)
t_emg = np.arange(0,n_emg*Ts_emg,Ts_emg)
t_emg

Fs_emg = 1000
Ts_emg = 1/Fs_emg
emgsignal = arrayemg[:, 5]
emgsignal = bsnb.raw_to_phy("EMG", "biosignalsplux", emgsignal, 10, "mV") #Pasamos la señal a mV
time = bsnb.generate_time(emgsignal, Fs_emg)
bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Amplitud (mV)")
bokeh_fig.line(time, emgsignal, legend_label="EMG data")
bokeh_fig.title.text = "Señal EMG Sin Filtrar"
bsnb.show(bokeh_fig)

# Eliminamos linea de base
emgsignal = emgsignal - np.mean(emgsignal)
emgsignal_2 = emgsignal - np.mean(emgsignal)

#Realizamos un analisis frecuencial a la señal
#Transformada de Fourier
fft_signal = np.fft.fft(emgsignal_2)
#Magnitud de la transformada de Fourier
mag_signal = np.abs(fft_signal)
#Frecuencias de la transformada
freqs = np.fft.fftfreq(len(emgsignal_2))

# Gráficas

#plt.plot(freqs*1000, mag_signal)
#plt.xlabel('Frecuencia (Hz)')
#plt.ylabel('Magnitud')
#plt.ylim([0, 300])
#plt.xlim([0, 500])
#plt.title("Espectro de Frecuencias, señal EMG sin filtrar")
#plt.show()

bokeh_fig = bsnb.figure(x_axis_label="Frecuencia (Hz)", y_axis_label="Magnitud", x_range=(0, 500))
bokeh_fig.line(freqs*1000, mag_signal, legend_label="EMG data")
bokeh_fig.title.text = "Espectro de frecuencia EMG Sin Filtrar"
bsnb.show(bokeh_fig)

# Creamos un filtro notch en 60 Hz
fc = 60.0  # Frecuencia a eliminar
Q = 20.0  # Factor de calidad
w0 = fc/(Fs_emg / 2)
b, a = iirnotch(w0, Q)

# Aplicamos el filtro creado
emgsignal_60Hz = lfilter(b, a, emgsignal_2)
# Transformada de Fourier para analisis frecuencial
fft_signal = np.fft.fft(emgsignal_60Hz)
freqs = np.fft.fftfreq(len(emgsignal_60Hz))
mag_signal = np.abs(fft_signal)

#Gráficamos el análisis frecuencial despues del filtro notch
bokeh_fig = bsnb.figure(x_axis_label="Frecuencia (Hz)", y_axis_label="Magnitud", x_range=(0,100))
bokeh_fig.line(freqs*1000, mag_signal, legend_label="EMG data filtro notch")
bokeh_fig.title.text = "Espectro de frecuencia EMG tras filtro Notch 60 Hz"
bsnb.show(bokeh_fig)

#Graficamos la señal luego del filtro notch 60Hz
bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Amplitud (mV)")
bokeh_fig.line(time, emgsignal_60Hz, legend_label="EMG data filtro notch")
bokeh_fig.title.text = "Señal EMG tras filtro Notch 60Hz"
bsnb.show(bokeh_fig)

#Filtrado con filtro pasabanda butterworth
fc_low = 20
fc_high = 400
emg_filtered = bsnb.aux_functions._butter_bandpass_filter(emgsignal_60Hz, fc_low, fc_high, Fs_emg)
#Graficamos la señal luego del filtro pasabanda Butterworth
bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Amplitud (mV)")
bokeh_fig.line(time, emg_filtered, legend_label="EMG data tras filtro pasabanda")
bokeh_fig.title.text = "Señal EMG Filtrada"
bsnb.show(bokeh_fig)

# Transformada de Fourier para analisis frecuencial
fft_signal = np.fft.fft(emg_filtered)
freqs = np.fft.fftfreq(len(emg_filtered))
mag_signal = np.abs(fft_signal)

#Gráficamos el análisis frecuencial despues del filtro notch
bokeh_fig = bsnb.figure(x_axis_label="Frecuencia (Hz)", y_axis_label="Magnitud", x_range=(10,420))
bokeh_fig.line(freqs*1000, mag_signal, legend_label="EMG data filtro pasabanda")
bokeh_fig.title.text = "Espectro de frecuencia EMG tras filtro pasabanda"
bsnb.show(bokeh_fig)

#Detección de eventos
mean_emg = np.average(emg_filtered)
std_emg = np.std(emg_filtered)

t_level1 = 1
t_l = mean_emg + t_level1 *std_emg
binary_signal = []
for i in range(0, len(time)):
    if emg_filtered[i] >= t_l:
        binary_signal.append(1)
    else:
        binary_signal.append(0)
binary_signal = np.array(binary_signal)
binary_signal *= int(np.max(emg_filtered))
bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Amplitud (mV)")
bokeh_fig.line(time, binary_signal,line_color='green', legend_label="Evento Detectado")
bokeh_fig.line(time, emg_filtered, legend_label="EMG data Filtrada")
bokeh_fig.title.text = "Señal Filtrada + Detección de eventos (contracciones)"


bsnb.show(bokeh_fig)

burst_begin, burst_end = bsnb.detect_emg_activations(emg_filtered, Fs_emg, smooth_level=100, threshold_level=2, time_units=True, plot_result=True)[:2]

#Detección de características
#Max mV
max_samp_val = np.max(emg_filtered)
#Min mV
min_samp_val = np.min(emg_filtered)
#RMS
rms = np.sqrt(np.sum(emg_filtered*emg_filtered))/len(emg_filtered)

emg_parametros = {"Maximum EMG (mV)": max_samp_val, "Minimum EMG (mV)": min_samp_val,
              "Average EMG (mV)": mean_emg, "Standard Deviation EMG": std_emg, "RMS EMG": rms}
print(emg_parametros)

#Rectificamos la señal
emg_filtered_rectificada = np.abs(emg_filtered)

# Media Movil
window_size = 500
i = 0
moving_averages = []
while i < len(emg_filtered_rectificada) - window_size + 1:
	window_average = round(np.sum(emg_filtered_rectificada[i:i+window_size]) / window_size, 2)
	moving_averages.append(window_average)
	i += 1

bokeh_fig = bsnb.figure(x_axis_label="Tiempo(s)", y_axis_label="Amplitud")
bokeh_fig.line(time, moving_averages, legend_label="Media móvil (RMS) de EMG")
bokeh_fig.title.text = "Gráfica media movil(RMS) de EMG tras procesar la señal"

bsnb.show(bokeh_fig)

"""## Ploteamos las señales sin filtrar



"""

plt.plot(t_emg, signalemg, label="señal")      # graficamos la señal
plt.grid(linestyle=":")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud(mV)")
plt.legend(loc="upper right")
plt.title("Señal EMG Sujeto Masculino - Sin Filtrar")
plt.show()